
package com.earwicker.cppjvm.cppwrap;

import java.lang.reflect.*;
import java.util.*;
import java.io.*;

public abstract class SourceGenerator {
    private PrintWriter writer;
    private Class<?> source;

    public static boolean putDefinitionsInHeaders = false;
    
    public String indent(String s) {
    		String indent = "    ";
    		return indent + s.replaceAll("\n", "\n" + indent);
    }
    public boolean dependsOnlyOnPrimitives(Method m) {
    		if (!m.getReturnType().isPrimitive())
    			return false;
    		for (Class c : m.getParameterTypes())
    			if (!c.isPrimitive())
    				return false;
    			
    		return true;
    }
    public String toString(Class<?> cls) throws Exception {
        source = cls;
        final Writer result = new StringWriter();
        writer = new PrintWriter(result);
        editWarning();
        generate();
        return result.toString();
    }

    protected PrintWriter out() {
        return writer;
    }

    protected Class<?> cls() {
        return source;
    }
    
    static Set<String> getMethodNames(Class c, boolean declaredMethodsOnly) {
    		Set<String> names = new HashSet<String>();
    		if (c != null)
    			for (Method m : (declaredMethodsOnly ? c.getDeclaredMethods() : c.getMethods()))
				names.add(m.getName());
		return names;
    }
    Method[] methods;
    protected Method[] methods() {
    		if (methods == null) {
    			Class cls = cls();
    			Set<String> parentMethodNames = getMethodNames(cls.getSuperclass(), false);
    			Set<String> declaredMethodNames = getMethodNames(cls, true);
    			List<Method> list = new ArrayList<Method>();
    			for (Method m : cls.getMethods()) {
    				String name = m.getName();
    				//if (name.equals("getClass") && m.getParameterTypes().length == 0)//cls != Object.class) continue;
    				//	//list.add(m);
    				
    				if (m.getDeclaringClass() == cls || parentMethodNames.contains(name) && declaredMethodNames.contains(name))
    					list.add(m);
    			}
    			methods = list.toArray(new Method[list.size()]);
    		}
    		return methods;
    }

    public abstract void generate() throws Exception;

    protected void editWarning() {
        out().println();
        out().println("//");
        out().println("// Do not edit this file - it was generated automatically from the Java class:");
        out().println("//");
        out().println("// " + cls().getName());
        out().println("//");
        out().println();
    }

    protected void include(Class<?> cls) {
        if (CppWrap.shouldGenerate(cls) && CppWrap.isWrapped(cls))
            out().println("#include <" + cls.getName().replace('.', '/') + ".hpp>");
    }

    protected void beginNamespace(Class<?> cls) {
        String[] namespaces = cls.getName().split("\\.");
        for (int n = 0; n < (namespaces.length - 1); n++)
            out().print(" namespace " + namespaces[n] + " {");
    }

    protected void endNamespace(Class<?> cls) {
        for (int n = 0; n < cls.getName().split("\\.").length - 1; n++)
            out().print(" }");
        out().println();
    }

    protected static final int DECLARE_TYPES = 0;
    protected static final int CALL_WRAPPED = 1;
    protected static final int CALL_UNWRAPPED = 2; 

    protected void listParameters(Class<?>[] params, int mode) throws Exception {
        int pos = 0;
        for (Class<?> p : params) {
            pos++;
            out().print(
                (pos > 1 ? ", " : "") + 
                (mode == DECLARE_TYPES 
                    ? (CppWrap.isWrapped(p) ? ("const " + CppWrap.cppType(p) + " &") : (CppWrap.cppType(p) + " "))
                    : "") + 
                "args" + pos + 
                (mode == CALL_UNWRAPPED && CppWrap.isWrapped(p) ? ".get_impl()" : "")
            );
        }
    }
}


